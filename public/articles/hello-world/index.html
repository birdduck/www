<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Hello World - Bird Duck Software
    </title>
    <link rel="alternate" href="http://birdducksoftware.com/feed.xml" type="application/rss+xml" title="We make it good.">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Hello World</h1>
        <p class="author">Written by <span class="author"><a href="mailto:the30yearswar@hotmail.com">Colin Teal</a></span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">defn</span></span> hello-world! <span class="collection">[]</span> <span class="list">(<span class="title">print</span> <span class="string">"hello world"</span>)</span>)</span></code></pre>
<h2>Wisp is a wonderful, interesting&nbsp;thing</h2>
<p><a href="https://github.com/Gozala/wisp">Wisp</a> is yet another language that transpiles to JavaScript, but with a very
noble goal of providing a native subset of <a href="http://clojure.org/">Clojure</a> and <a href="https://github.com/clojure/clojurescript">Clojurescript</a>.
Achieving this mission should provide portability between the two 
(and JavaScript when compiled). This is <em>fantastic</em>.</p>
<p>In the quest to learn functional programming without the overhead of an invasive
Java installation or worrying about <a href="https://github.com/technomancy/leiningen">leiningen</a>, Wisp, which you
<a href="http://jeditoolkit.com/try-wisp/">really must try</a>, was a bright light in an otherwise stark darkness.
During our stay here it would be nice to <a href="https://github.com/Gozala/wisp/issues/19">help the burgeoning language out</a>&nbsp;too.</p>
<p>Parsing arguments on the command line is not a traditionally fun, rewarding
exercise. Luckily there are several viable open source implementations that can
serve as inspiration. Given the general success of <a href="http://coffeescript.org/">CoffeeScript</a>, an answer
to <a href="http://www.ruby-lang.org/">Ruby</a>, it seems a natural place to&nbsp;start.</p>
<p>Take <a href="http://coffeescript.org/documentation/docs/optparse.html#section-10">this innocuous helper function</a> defined in <code>optparse.coffee</code> for&nbsp;instanceâ€¦</p>
<pre><code class="lang-coffeescript"><span class="function"><span class="title">buildRules</span></span> = (rules) -&gt;
  <span class="keyword">for</span> tuple <span class="keyword">in</span> rules
    tuple.unshift <span class="literal">null</span> <span class="keyword">if</span> tuple.length &lt; <span class="number">3</span>
    buildRule tuple...</code></pre>
<p>The first step to approximating this function is defining its analogue in&nbsp;Wisp.</p>
<pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">defn</span></span> build-rules
  <span class="collection">[rules]</span>)</span></code></pre>
<p>At first glance you might notice the difference in the names of the functions.
When this Wisp code is transpiled the function will be translated into a
<a href="http://c2.com/cgi/wiki?CamelCase">camel cased</a>&nbsp;version.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> buildRules = <span class="function"><span class="keyword">function</span> <span class="title">buildRules</span><span class="params">(rules)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">void</span>(<span class="number">0</span>);
};</code></pre>
<p>This is <a href="https://github.com/Gozala/wisp#conventions">one of the many clever features</a> of the Wisp language coming 
to the&nbsp;rescue!</p>
<p>To continue the exercise of approximation a key insight can be gleaned in the
original. Rather than simply iterating over the arrays in <code>rules</code> we can instead
use the <code>map</code> function with the preexisting function, defined somewhere deep in
the innermost recesses of <code>optparse.coffee</code>, called <code>buildRule</code>.</p>
<pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">defn</span></span> build-rules
  <span class="collection">[rules]</span>
  <span class="list">(<span class="title"><span class="built_in">map</span></span> build-rule rules)</span>)</span></code></pre>
<p>Simple as that, right? Not quite. Every good translation should maintain fidelity
with the source material, and therefore we have no choice but to incorporate
the conditional prepend of <code>null</code> to the rule when the <code>length</code> is less than three.
Luckily we can define a function inline just like&nbsp;JavaScript.</p>
<pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">defn</span></span> build-rules
  <span class="collection">[rules]</span>
  <span class="list">(<span class="title"><span class="built_in">map</span></span>
    <span class="list">(<span class="title"><span class="built_in">fn</span></span>
      <span class="collection">[rule]</span>
      <span class="list">(<span class="title">build-rule</span> 
        <span class="list">(<span class="title"><span class="built_in">if</span></span> <span class="list">(<span class="title"><span class="built_in">&lt;</span></span> <span class="list">(<span class="title"><span class="built_in">count</span></span> rule)</span><span class="number"> 3</span>)</span>
          <span class="list">(<span class="title"><span class="built_in">concat</span></span> <span class="literal">nil</span> rule)</span>
          rule)</span>)</span>)</span>
    rules)</span>)</span></code></pre>
<p>That wasn&#39;t so hard, was it? There are a few differences in implementation that
are obvious. Rather than <code>null</code> there is <code>nil</code>. A key difference between the two
is that in the transpiled code <code>nil</code> will actually become <code>void(0)</code>, or
<code>undefined</code> as it is more commonly known. Rather than use native properties or
functions to retrieve the <code>length</code> and prepend an item there is <code>count</code> and
<code>concat</code>. These functions are imported from the <code>wisp.sequence</code> namespace.</p>
<pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">ns</span></span> wisp.optparse
  <span class="string">"Wisp command line parsing"</span>
  <span class="list">(:<span class="title">require</span> <span class="collection">[wisp.sequence <span class="attribute">:refer</span> <span class="collection">[count concat map]</span>]</span>)</span>)</span></code></pre>
<p>One more thing: this function isn&#39;t quite right. The CoffeeScript literate
already know what is missing, but for those learning as we go it comes down to
the ellipsis trailing that woeful <code>tuple</code>. A clue lurks in <a href="http://coffeescript.org/documentation/docs/optparse.html#section-11">the definition</a> of
<code>buildRule</code>.</p>
<pre><code class="lang-coffeescript"><span class="function"><span class="title">buildRule</span></span> = (shortFlag, longFlag, description, options = {}) -&gt;
  match     = longFlag.match(<span class="caps">OPTIONAL</span>)
  longFlag  = longFlag.match(LONG_FLAG)[<span class="number">1</span>]
  {
    name:         longFlag.substr <span class="number">2</span>
    shortFlag:    shortFlag
    longFlag:     longFlag
    description:  description
    hasArgument:  !!(match <span class="keyword">and</span> match[<span class="number">1</span>])
    isList:       !!(match <span class="keyword">and</span> match[<span class="number">2</span>])
  }</code></pre>
<p>Do you see it? That&#39;s absolutely right. This function takes several arguments and
not a single array! This means that rather than using <code>rule</code> or <code>tuple</code> as the
sole argument that the items that comprise them should be used instead. What this
really means is that our <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">ol&#39; friend</a> <code>apply</code> is at it again. Fret not, for
Wisp has an&nbsp;answer.</p>
<pre><code class="lang-clojure"><span class="list">(<span class="title"><span class="built_in">defn</span></span> build-rules
  <span class="collection">[rules]</span>
  <span class="list">(<span class="title"><span class="built_in">map</span></span>
    <span class="list">(<span class="title"><span class="built_in">fn</span></span>
      <span class="collection">[rule]</span> 
      <span class="list">(<span class="title"><span class="built_in">apply</span></span> build-rule 
        <span class="list">(<span class="title"><span class="built_in">if</span></span> <span class="list">(<span class="title"><span class="built_in">&lt;</span></span> <span class="list">(<span class="title"><span class="built_in">count</span></span> rule)</span><span class="number"> 3</span>)</span>
          <span class="list">(<span class="title"><span class="built_in">concat</span></span> <span class="literal">nil</span> rule)</span> 
          rule)</span>)</span>)</span>
    rules)</span>)</span></code></pre>
<p>Perfect. Out of curiosity, edification let&#39;s compare the results of transpiling
each of these functions from their respective&nbsp;language.</p>
<p>The result of compiling the CoffeeScript&nbsp;version:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> buildRules;

buildRules = <span class="keyword">function</span>(rules) {
  <span class="keyword">var</span> tuple, _i, _len, _results;
  _results = [];
  <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = rules.length; _i &lt; _len; _i++) {
    tuple = rules[_i];
    <span class="keyword">if</span> (tuple.length &lt; <span class="number">3</span>) {
      tuple.unshift(<span class="literal">null</span>);
    }
    _results.push(buildRule.apply(<span class="literal">null</span>, tuple));
  }
  <span class="keyword">return</span> _results;
};x</code></pre>
<p>The result of compiling the Wisp&nbsp;version:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> buildRules = <span class="function"><span class="keyword">function</span> <span class="title">buildRules</span><span class="params">(rules)</span> {</span>
  <span class="keyword">return</span> map(<span class="keyword">function</span>(rule) {
    <span class="keyword">return</span> buildRule.apply(buildRule, count(rule) &lt; <span class="number">3</span> ?
      concat(<span class="keyword">void</span>(<span class="number">0</span>), rule) :
      rule);
  }, rules);
};</code></pre>
<p>Okay, this may not be comparing apples to apples, as the functions <code>count</code>, <code>concat</code>,
and <code>map</code> that were imported from <code>wisp.sequence</code> are not included, but it is short
and it is sweet (much like an&nbsp;orange). </p>
<p>There is much more to learn as we wander deeper into the woods of&nbsp;Wispâ€¦</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">Â« Full blog</a></div>
        <section class="about">
        </section>
        <section class="copy">
          <p>&copy; 2013 Bird Duck Software &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>