<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bird Duck Software</title>
    <atom:link href="http://birdducksoftware.com/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://birdducksoftware.com</link>
    <description>We make it good.</description>
    <pubDate>Tue, 30 Sep 2014 11:15:00 +0000</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Random Avatars, Approximately</title>
      <link>http://birdducksoftware.com/articles/random-avatars-approximately/</link>
      <pubDate>Tue, 30 Sep 2014 11:15:00 +0000</pubDate>
      <guid isPermaLink="true">http://birdducksoftware.com/articles/random-avatars-approximately/</guid>
      <author></author>
      <description>&lt;p&gt;We had a problem while working on &lt;a href=&quot;http://monsters.io&quot;&gt;World of Monsters&lt;/a&gt;: how can aesthetic
traits be randomized predictably in a fashion that can be easily reproduced?
The long term goal is to use inheritable genes, but to bring monsters
temporarily to life we needed…&lt;em&gt;something&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;eureka-something-like-noise-functions-and-avatars-&quot;&gt;Eureka, something like noise functions and avatars!&lt;/h2&gt;
&lt;p&gt;This problem &lt;a href=&quot;http://blog.gravatar.com/2008/04/22/identicons-monsterids-and-wavatars-oh-my/&quot;&gt;has been solved before&lt;/a&gt;, and probably better, but this is what we
ended up with. Sometimes being deficient in mathematics can make the adventure
that is software development more fun, albeit woefully inefficient.&lt;/p&gt;
&lt;p&gt;First, we need a deterministic seed. Luckily for us, each monster has a name and
an identifier. We know that each character in the name of a monster can be
&lt;a href=&quot;http://www.asciitable.com/&quot;&gt;represented with a decimal in ASCII&lt;/a&gt;. Perfect.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterSeed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// default seed to the monster id, giving it&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// some uniqueness&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; seed = monster.id;
  &lt;span class=&quot;comment&quot;&gt;// grab the monster name, as it is more flavor&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = monster.name

  &lt;span class=&quot;comment&quot;&gt;// iterate over each character in the name, adding&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// its value to our seed&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, l = name.length; i &amp;lt; l; i++) {
    seed += name.charCodeAt(i);
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; seed;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a deterministic seed from a monster, we can use this value to
generate psuedo-random numbers, which become useful with the help of this simple
method (which is based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random&quot;&gt;an implementation here&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getRandomInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(min, max, seed)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// if a seed is specified use it, otherwise create one&lt;/span&gt;
  seed = seed || &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random();
  &lt;span class=&quot;comment&quot;&gt;// generate a random integer within the specified range&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(seed * (max - min)) + min;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great. So we have our seed, and we have a method to generate random integers
within a range. How can we use this to get monster traits? Well, that’s simple.
We need to generate trait seeds from our base seed.
Let’s see what that might look like for eye color.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterEyeColorSeed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// start with the base monster seed (an integer)&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorSeed = getMonsterSeed(monster);

  &lt;span class=&quot;comment&quot;&gt;// boil down our seed by some fraction until it is a decimal&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// it is important that all methods generating a sub-seed do&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// so in a fashion that does not collide with others&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (eyeColorSeed &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) {
    eyeColorSeed /= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; eyeColorSeed;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK. Now we have an eye color seed that is a decimal, in addition to having a
base seed integer. What are we going to do with our trait seed that will suddenly
turn into something expressive, that we can, like, see? Remember our random range
method, and the optional seed parameter? Well…this might be easier done than said.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterEyeColor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// here are the available eye colors&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColors = [
    &lt;span class=&quot;string&quot;&gt;'334F53'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'C8C9C9'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'574840'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'5F6401'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'C5DAED'&lt;/span&gt;
  ];

  &lt;span class=&quot;comment&quot;&gt;// let's get the eye color seed for this monster&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorSeed = getMonsterEyeColorSeed(monster);

  &lt;span class=&quot;comment&quot;&gt;// ah ha! now we use the eye color seed to grab a color&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// out of our array&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorIndex = getRandomInt(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, eyeColors.length,
    eyeColorSeed) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'#'&lt;/span&gt; + eyeColors[eyeColorIndex];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With everything we built above, we now have a method for getting a monster’s eye
color that is somewhat random. Random enough, anyway. Never mind that our model
breaks down when a monster legally changes their name, or that the distribution
of traits is by no means sound (maybe this is okay, it is a lot closer to how
genes actually work). You’ll need to suspend your disbelief with respect to
collisions (they are &lt;strong&gt;totally possible&lt;/strong&gt;) between monster seeds. The worst
that can happen is two monsters without a common lineage accidentally share the
exact same genetic material. It’s good enough, for now, and maybe it is good
enough for you.&lt;/p&gt;
&lt;p&gt;Let’s see the entire thing, shall we.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getRandomInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(min, max, seed)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// if a seed is specified use it, otherwise create one&lt;/span&gt;
  seed = seed || &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random();
  &lt;span class=&quot;comment&quot;&gt;// generate a random integer within the specified range&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(seed * (max - min)) + min;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterSeed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// default seed to the monster id, giving it&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// some uniqueness&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; seed = monster.id;
  &lt;span class=&quot;comment&quot;&gt;// grab the monster name, as it is more flavor&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = monster.name

  &lt;span class=&quot;comment&quot;&gt;// iterate over each character in the name, adding&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// its value to our seed&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, l = name.length; i &amp;lt; l; i++) {
    seed += name.charCodeAt(i);
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; seed;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterEyeColorSeed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// start with the base monster seed (an integer)&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorSeed = getMonsterSeed(monster);

  &lt;span class=&quot;comment&quot;&gt;// boil down our seed by some fraction until it is a decimal&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// it is important that all methods generating a sub-seed do&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// so in a fashion that does not collide with others&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (eyeColorSeed &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) {
    eyeColorSeed /= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; eyeColorSeed;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMonsterEyeColor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(monster)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// here are the available eye colors&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColors = [
    &lt;span class=&quot;string&quot;&gt;'334F53'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'C8C9C9'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'574840'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'5F6401'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'C5DAED'&lt;/span&gt;
  ];

  &lt;span class=&quot;comment&quot;&gt;// let's get the eye color seed for this monster&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorSeed = getMonsterEyeColorSeed(monster);

  &lt;span class=&quot;comment&quot;&gt;// ah ha! now we use the eye color seed to grab a color&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;// out of our array&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eyeColorIndex = getRandomInt(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, eyeColors.length,
    eyeColorSeed) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// pound it out&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'#'&lt;/span&gt; + eyeColors[eyeColorIndex];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And how might we use this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// what a vile creature that Kevin is...&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; monster = { id: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, name: &lt;span class=&quot;string&quot;&gt;'Kevin'&lt;/span&gt; };
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; monsterEyeColor = getMonsterEyeColor(monster);
console.log(monsterEyeColor); &lt;span class=&quot;comment&quot;&gt;// #574840&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proof that it is psuedo-random, dynamic?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// STELLLLLLAAAAAAAAAAAAAAAAAAAAAAAAA...&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; monster = { id: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, name: &lt;span class=&quot;string&quot;&gt;'Stella'&lt;/span&gt; };
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; monsterEyeColor = getMonsterEyeColor(monster);
console.log(monsterEyeColor); &lt;span class=&quot;comment&quot;&gt;// #5F6401&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is how &lt;a href=&quot;http://monsters.io&quot;&gt;World of Monsters&lt;/a&gt; at present generates &lt;a href=&quot;https://dl.dropboxusercontent.com/u/37456399/monster.png&quot;&gt;random monster renderings&lt;/a&gt;
that never differ, and are always the same for each monster. The body, and eye color
are driven by the technique laid out above. We might use this approach to determine
if monsters have horns and how many of them, whether they have hair and what color,
and perhaps even subtle information about appendages (flippers, tentacles,
arms, etc.). Who knows!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>http://birdducksoftware.com/articles/hello-world/</link>
      <pubDate>Wed, 24 Jul 2013 11:15:00 +0000</pubDate>
      <guid isPermaLink="true">http://birdducksoftware.com/articles/hello-world/</guid>
      <author></author>
      <description>&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; hello-world! &lt;span class=&quot;collection&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;wisp-is-a-wonderful-interesting-thing&quot;&gt;Wisp is a wonderful, interesting thing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Gozala/wisp&quot;&gt;Wisp&lt;/a&gt; is yet another language that transpiles to JavaScript, but with a very
noble goal of providing a native subset of &lt;a href=&quot;http://clojure.org/&quot;&gt;Clojure&lt;/a&gt; and &lt;a href=&quot;https://github.com/clojure/clojurescript&quot;&gt;Clojurescript&lt;/a&gt;.
Achieving this mission should provide portability between the two 
(and JavaScript when compiled). This is &lt;em&gt;fantastic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the quest to learn functional programming without the overhead of an invasive
Java installation or worrying about &lt;a href=&quot;https://github.com/technomancy/leiningen&quot;&gt;leiningen&lt;/a&gt;, Wisp, which you
&lt;a href=&quot;http://jeditoolkit.com/try-wisp/&quot;&gt;really must try&lt;/a&gt;, was a bright light in an otherwise stark darkness.
During our stay here it would be nice to &lt;a href=&quot;https://github.com/Gozala/wisp/issues/19&quot;&gt;help the burgeoning language out&lt;/a&gt; too.&lt;/p&gt;
&lt;p&gt;Parsing arguments on the command line is not a traditionally fun, rewarding
exercise. Luckily there are several viable open source implementations that can
serve as inspiration. Given the general success of &lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;, an answer
to &lt;a href=&quot;http://www.ruby-lang.org/&quot;&gt;Ruby&lt;/a&gt;, it seems a natural place to start.&lt;/p&gt;
&lt;p&gt;Take &lt;a href=&quot;http://coffeescript.org/documentation/docs/optparse.html#section-10&quot;&gt;this innocuous helper function&lt;/a&gt; defined in &lt;code&gt;optparse.coffee&lt;/code&gt; for instance…&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-coffeescript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;buildRules&lt;/span&gt; = &lt;span class=&quot;params&quot;&gt;(rules)&lt;/span&gt; -&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; tuple &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; rules
    tuple.unshift &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; tuple.length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;
    buildRule tuple...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first step to approximating this function is defining its analogue in Wisp.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; build-rules
  &lt;span class=&quot;collection&quot;&gt;[rules]&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first glance you might notice the difference in the names of the functions.
When this Wisp code is transpiled the function will be translated into a
&lt;a href=&quot;http://c2.com/cgi/wiki?CamelCase&quot;&gt;camel cased&lt;/a&gt; version.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; buildRules = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;buildRules&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rules)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is &lt;a href=&quot;https://github.com/Gozala/wisp#conventions&quot;&gt;one of the many clever features&lt;/a&gt; of the Wisp language coming 
to the rescue!&lt;/p&gt;
&lt;p&gt;To continue the exercise of approximation a key insight can be gleaned in the
original. Rather than simply iterating over the arrays in &lt;code&gt;rules&lt;/code&gt; we can instead
use the &lt;code&gt;map&lt;/code&gt; function with the preexisting function, defined somewhere deep in
the innermost recesses of &lt;code&gt;optparse.coffee&lt;/code&gt;, called &lt;code&gt;buildRule&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; build-rules
  &lt;span class=&quot;collection&quot;&gt;[rules]&lt;/span&gt;
  &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt; build-rule rules)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simple as that, right? Not quite. Every good translation should maintain fidelity
with the source material, and therefore we have no choice but to incorporate
the conditional prepend of &lt;code&gt;null&lt;/code&gt; to the rule when the &lt;code&gt;length&lt;/code&gt; is less than three.
Luckily we can define a function inline just like JavaScript.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; build-rules
  &lt;span class=&quot;collection&quot;&gt;[rules]&lt;/span&gt;
  &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;fn&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;collection&quot;&gt;[rule]&lt;/span&gt;
      &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;build-rule&lt;/span&gt; 
        &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;if&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt; rule)&lt;/span&gt;&lt;span class=&quot;number&quot;&gt; 3&lt;/span&gt;)&lt;/span&gt;
          &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;concat&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; rule)&lt;/span&gt;
          rule)&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;
    rules)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That wasn’t so hard, was it? There are a few differences in implementation that
are obvious. Rather than &lt;code&gt;null&lt;/code&gt; there is &lt;code&gt;nil&lt;/code&gt;. A key difference between the two
is that in the transpiled code &lt;code&gt;nil&lt;/code&gt; will actually become &lt;code&gt;void(0)&lt;/code&gt;, or
&lt;code&gt;undefined&lt;/code&gt; as it is more commonly known. Rather than use native properties or
functions to retrieve the &lt;code&gt;length&lt;/code&gt; and prepend an item there is &lt;code&gt;count&lt;/code&gt; and
&lt;code&gt;concat&lt;/code&gt;. These functions are imported from the &lt;code&gt;wisp.sequence&lt;/code&gt; namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ns&lt;/span&gt;&lt;/span&gt; wisp.optparse
  &lt;span class=&quot;string&quot;&gt;&quot;Wisp command line parsing&quot;&lt;/span&gt;
  &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;attribute&quot;&gt;:require&lt;/span&gt; &lt;span class=&quot;collection&quot;&gt;[wisp.sequence &lt;span class=&quot;attribute&quot;&gt;:refer&lt;/span&gt; &lt;span class=&quot;collection&quot;&gt;[count concat map]&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One more thing: this function isn’t quite right. The CoffeeScript literate
already know what is missing, but for those learning as we go it comes down to
the ellipsis trailing that woeful &lt;code&gt;tuple&lt;/code&gt;. A clue lurks in &lt;a href=&quot;http://coffeescript.org/documentation/docs/optparse.html#section-11&quot;&gt;the definition&lt;/a&gt; of
&lt;code&gt;buildRule&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-coffeescript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;buildRule&lt;/span&gt; = &lt;span class=&quot;params&quot;&gt;(shortFlag, longFlag, description, options = {})&lt;/span&gt; -&amp;gt;&lt;/span&gt;
  match     = longFlag.match(OPTIONAL)
  longFlag  = longFlag.match(LONG_FLAG)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]
  {
    &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;:         longFlag.substr &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;attribute&quot;&gt;shortFlag&lt;/span&gt;:    shortFlag
    &lt;span class=&quot;attribute&quot;&gt;longFlag&lt;/span&gt;:     longFlag
    &lt;span class=&quot;attribute&quot;&gt;description&lt;/span&gt;:  description
    &lt;span class=&quot;attribute&quot;&gt;hasArgument&lt;/span&gt;:  !!(match &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; match[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])
    &lt;span class=&quot;attribute&quot;&gt;isList&lt;/span&gt;:       !!(match &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; match[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do you see it? That’s absolutely right. This function takes several arguments and
not a single array! This means that rather than using &lt;code&gt;rule&lt;/code&gt; or &lt;code&gt;tuple&lt;/code&gt; as the
sole argument that the items that comprise them should be used instead. What this
really means is that our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;ol’ friend&lt;/a&gt; &lt;code&gt;apply&lt;/code&gt; is at it again. Fret not, for
Wisp has an answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-clojure&quot;&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; build-rules
  &lt;span class=&quot;collection&quot;&gt;[rules]&lt;/span&gt;
  &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;fn&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;collection&quot;&gt;[rule]&lt;/span&gt; 
      &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;apply&lt;/span&gt;&lt;/span&gt; build-rule 
        &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;if&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt; rule)&lt;/span&gt;&lt;span class=&quot;number&quot;&gt; 3&lt;/span&gt;)&lt;/span&gt;
          &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;concat&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; rule)&lt;/span&gt; 
          rule)&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;
    rules)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perfect. Out of curiosity, edification let’s compare the results of transpiling
each of these functions from their respective language.&lt;/p&gt;
&lt;p&gt;The result of compiling the CoffeeScript version:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; buildRules;

buildRules = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rules)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tuple, _i, _len, _results;
  _results = [];
  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (_i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, _len = rules.length; _i &amp;lt; _len; _i++) {
    tuple = rules[_i];
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tuple.length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) {
      tuple.unshift(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);
    }
    _results.push(buildRule.apply(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, tuple));
  }
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _results;
};x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of compiling the Wisp version:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; buildRules = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;buildRules&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rules)&lt;/span&gt; {&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rule)&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; buildRule.apply(buildRule, count(rule) &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ?
      concat(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), rule) :
      rule);
  }, rules);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, this may not be comparing apples to apples, as the functions &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;,
and &lt;code&gt;map&lt;/code&gt; that were imported from &lt;code&gt;wisp.sequence&lt;/code&gt; are not included, but it is short
and it is sweet (much like an orange). &lt;/p&gt;
&lt;p&gt;There is much more to learn as we wander deeper into the woods of Wisp…&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>